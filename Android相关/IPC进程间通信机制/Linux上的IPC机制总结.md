# Linux上IPC机制总结

Linux上主要采用以下集中集中IPC机制进行进程间的通信

1. **管道 （PIPE）**
2. **命名管道（FIFO）**
3. **信号 （signal）**
4. **消息队列（Message queues）**
5. **信号量（Semaphore）**
6. **共享内存（Share Memory）**
7. **内存映射（Memory Map）**
8. **套接字(Socket)** 

## 1#管道（PIPE） ##

><font color = "#007FFF">**管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。**</font>


实现机制：<br>
 **管道是由内核管理的一个缓冲区**，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。

<br>**<font color = "#007FFF">管道只能在本地计算机中使用，而不可用于网络间的通信。</font>** 

管道的特点：
<br>1、**管道是半双工的，数据只能向一个方向流动；<font color = "red">需要双方通信时，需要建立起两个管道；</font>**
<br>2、**<font color = "red">只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）</font>**。比如fork或exec创建的新进程，在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。
<br>3、**单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，<font color = "red">单独构成一种文件系统，并且只存在与内存中</font>**。
<br>4、**数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。<font color = "red">写入与读取的顺序原则是先进先出。</font>**

## 2#命名管道（FIFO） ##
>**<font color = "#007FFF">命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了管道的弊端，他可以允许没有亲缘关系的进程间通信</font>**

**具体操作方法只要创建了一个命名管道然后就可以使用open、read、write等系统调用来操作。创建可以手工创建或者程序中创建**

**管道和命名管道的区别：**<br>
<font color = "red">**命名管道(FIFO)克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信**</font><br>
对于**命名管道FIFO**来说，IO操作和**普通管道PIPE** IO操作基本一样，但是两者有一个主要的区别，**在命名管道中，管道可以是事先已经创建好的，比如我们在命令行下执行
mkfifo myfifo
就是创建一个命名通道，我们必须用open函数来显示地建立连接到管道的通道，而在管道中，管道已经在主进程里创建好了，然后在fork时直接复制相关数据或者是用exec创建的新进程时把管道的文件描述符当参数传递进去。**
一般来说FIFO和PIPE一样总是处于阻塞状态。也就是说如果命名管道FIFO打开时设置了读权限，则读进程将一直阻塞，一直到其他进程打开该FIFO并向管道写入数据。这个阻塞动作反过来也是成立的。如果不希望命名管道操作的时候发生阻塞，可以在open的时候使用O_NONBLOCK标志，以关闭默认的阻塞操作。


## 3#信号 （signal） ##

>**<font color = "#007FFF">信号机制是unix系统中最为古老的进程之间的通信机制，用于一个或几个进程之间传递异步信号。信号可以有各种异步事件产生，比如键盘中断等。shell也可以使用信号将作业控制命令传递给它的子进程</font>**

<br><font color = "red">**主要作为进程间以及同一进程不同线程之间的同步手段。**</font>

## 4#消息队列（Message queues） ##

>**<font color = "#007FFF">消息队列是内核地址空间中的内部链表，通过linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。内核中的消息队列是通过IPC的标识符来区别，不同的消息队列直接是相互独立的。每个消息队列中的消息，又构成一个独立的链表。</font>**

<br>**消息队列克服了信号承载信息量少，管道只能承载无格式字符流的问题。**

Linux的消息队列(queue)实质**上是一个链表，它有消息队列标识符(queue ID)。 <font color = "red">msgget创建一个新队列或打开一个存在的队列；msgsnd向队列末端添加一条新消息；msgrcv从队列中取消息， 取消息是不一定遵循先进先出的， 也可以按消息的类型字段取消息。</font>**

**消息队列与命名管道的比较**<br>
<font color = "red">消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write，接收数据用read，则在消息队列中，发送数据用msgsnd，接收数据用msgrcv。而且它们对每个数据都有一个最大长度的限制。<br>
与命名管道相比，消息队列的优势在于，1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。</font>

## 5#信号量（Semaphore） ##


## 6#共享内存（Share Memory） ##
## 7#内存映射（Memory Map） ##
## 8#套接字(Socket) ##









---
>参考：<br>
>[https://blog.csdn.net/a987073381/article/details/52006729](https://blog.csdn.net/a987073381/article/details/52006729 "linux基础——linux进程间通信（IPC）机制总结") 
>[https://blog.csdn.net/gatieme/article/details/50908749](https://blog.csdn.net/gatieme/article/details/50908749 "Linux进程间通信的几种方式总结--linux内核剖析")