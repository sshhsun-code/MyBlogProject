# Linux上IPC机制总结

Linux上主要采用以下集中集中IPC机制进行进程间的通信

1. **管道 （PIPE）**
2. **命名管道（FIFO）**
3. **信号 （signal）**
4. **消息队列（Message queues）**
5. **信号量（Semaphore）**
6. **共享内存（Share Memory）**
7. **内存映射（Memory Map）**
8. **套接字(Socket)** 

## 1#管道（PIPE） ##

><font color = "#007FFF">**管道实际是用于进程间通信的一段共享内存，创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。**</font>


实现机制：<br>
 **管道是由内核管理的一个缓冲区**，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。

<br>**<font color = "#007FFF">管道只能在本地计算机中使用，而不可用于网络间的通信。</font>** 

管道的特点：
<br>1、**管道是半双工的，数据只能向一个方向流动；<font color = "red">需要双方通信时，需要建立起两个管道；</font>**
<br>2、**<font color = "red">只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）</font>**。比如fork或exec创建的新进程，在使用exec创建新进程时，需要将管道的文件描述符作为参数传递给exec创建的新进程。当父进程与使用fork创建的子进程直接通信时，发送数据的进程关闭读端，接受数据的进程关闭写端。
<br>3、**单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，<font color = "red">单独构成一种文件系统，并且只存在与内存中</font>**。
<br>4、**数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。<font color = "red">写入与读取的顺序原则是先进先出。</font>**

## 2#命名管道（FIFO） ##
>**<font color = "#007FFF">命名管道是一种特殊类型的文件，它在系统中以文件形式存在。这样克服了管道的弊端，他可以允许没有亲缘关系的进程间通信</font>**

**具体操作方法只要创建了一个命名管道然后就可以使用open、read、write等系统调用来操作。创建可以手工创建或者程序中创建**

**管道和命名管道的区别：**<br>
<font color = "red">**命名管道(FIFO)克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信**</font><br>
对于**命名管道FIFO**来说，IO操作和**普通管道PIPE** IO操作基本一样，但是两者有一个主要的区别，**在命名管道中，管道可以是事先已经创建好的，比如我们在命令行下执行
mkfifo myfifo
就是创建一个命名通道，我们必须用open函数来显示地建立连接到管道的通道，而在管道中，管道已经在主进程里创建好了，然后在fork时直接复制相关数据或者是用exec创建的新进程时把管道的文件描述符当参数传递进去。**
一般来说FIFO和PIPE一样总是处于阻塞状态。也就是说如果命名管道FIFO打开时设置了读权限，则读进程将一直阻塞，一直到其他进程打开该FIFO并向管道写入数据。这个阻塞动作反过来也是成立的。如果不希望命名管道操作的时候发生阻塞，可以在open的时候使用O_NONBLOCK标志，以关闭默认的阻塞操作。


## 3#信号 （signal） ##

>**<font color = "#007FFF">信号机制是unix系统中最为古老的进程之间的通信机制，用于一个或几个进程之间传递异步信号。信号可以有各种异步事件产生，比如键盘中断等。shell也可以使用信号将作业控制命令传递给它的子进程</font>**

<br><font color = "red">**主要作为进程间以及同一进程不同线程之间的同步手段。**</font>

## 4#消息队列（Message queues） ##

>**<font color = "#007FFF">消息队列是内核地址空间中的内部链表，通过linux内核在各个进程直接传递内容，消息顺序地发送到消息队列中，并以几种不同的方式从队列中获得，每个消息队列可以用IPC标识符唯一地进行识别。内核中的消息队列是通过IPC的标识符来区别，不同的消息队列直接是相互独立的。每个消息队列中的消息，又构成一个独立的链表。</font>**

<br>**消息队列克服了信号承载信息量少，管道只能承载无格式字符流的问题。**

Linux的消息队列(queue)实质**上是一个链表，它有消息队列标识符(queue ID)。 <font color = "red">msgget创建一个新队列或打开一个存在的队列；msgsnd向队列末端添加一条新消息；msgrcv从队列中取消息， 取消息是不一定遵循先进先出的， 也可以按消息的类型字段取消息。</font>**

**消息队列与命名管道的比较**<br>
<font color = "red">消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write，接收数据用read，则在消息队列中，发送数据用msgsnd，接收数据用msgrcv。而且它们对每个数据都有一个最大长度的限制。<br>
与命名管道相比，消息队列的优势在于，1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。</font>

## 5#信号量（Semaphore） ##
><font color = "#007FFF">信号量是一种计数器，用于控制对多个进程共享的资源进行的访问。<font color = "red"><strong>它们常常被用作一个锁机制，在某个进程正在对特定的资源进行操作时，信号量可以防止另一个进程去访问它。</strong></font> 
信号量是特殊的变量，它只取正整数值并且只允许对这个值进行两种操作：等待（wait）和信号（signal）。（P、V操作，P用于等待，V用于信号）
<br>p(sv):如果sv的值大于0，就给它减1；如果它的值等于0，就挂起该进程的执行 
<br>V(sv):如果有其他进程因等待sv而被挂起，就让它恢复运行；如果没有其他进程因等待sv而挂起，则给它加1 
<br>**简单理解就是P相当于申请资源，V相当于释放资源** 

## 6#共享内存（Share Memory） ##
>共享内存是在多个进程之间共享内存区域的一种进程间的通信方式，由IPC为进程创建的一个特殊地址范围，它将出现在该进程的地址空间中。其他进程可以将**同一段共享内存**连接到自己的地址空间中。所有进程都可以访问共享内存中的地址，就好像它们是malloc分配的一样。如果一个进程向共享内存中写入了数据，所做的改动将立刻被其他进程看到.
><br><font color = "red">**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。**</font></font>


共享内存是IPC最快捷的方式，**因为共享内存方式的通信没有中间过程，而管道、消息队列等方式则是需要将数据通过中间机制进行转换。共享内存方式直接将某段内存段进行映射，多个进程间的共享内存是同一块的物理空间，仅仅映射到各进程的地址不同而已，因此不需要进行复制，可以直接使用此段空间**。

**注意：共享内存本身并没有同步机制，需要程序员自己控制。**



## 7#内存映射（Memory Map） ##

><font color = "#007FFF">内存映射文件，是**由一个文件到一块内存的映射**。内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址的区域，
同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作。<font color = "red">**每一个使用该机制的进程通过把同一个共享的文件映射到自己的进程地址空间来实现多个进程间的通信（这里类似于共享内存，只要有一个进程对这块映射文件的内存进行操作，其他进程也能够马上看到）**</font></font>

使用内存映射文件不仅可以实现多个进程间的通信，还可以用于**处理大文件提高效率**。因为我们普通的做法是把磁盘上的文件先拷贝到内核空间的一个缓冲区再拷贝到用户空间（内存），用户修改后再将这些数据拷贝到缓冲区再拷贝到磁盘文件，一共四次拷贝。如果文件数据量很大，拷贝的开销是非常大的。那么问题来了，系统在在进行内存映射文件就不需要数据拷贝？mmap()确实没有进行数据拷贝，真正的拷贝是在在缺页中断处理时进行的，**由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，所以只进行一次数据拷贝。效率高于read/write。**

**共享内存和内存映射文件的区别：**<br>
内存映射文件是利用虚拟内存把文件映射到进程的地址空间中去，在此之后进程操作文件，就像操作进程空间里的地址一样了，比如使用c语言的memcpy等内存操作的函数。这种方法能够很好的应用在需要频繁处理一个文件或者是一个大文件的场合，这种方式处理IO效率比普通IO效率要高.共享内存是内存映射文件的一种特殊情况，内存映射的是一块内存，而非磁盘上的文件。共享内存的主语是进程（Process），操作系统默认会给每一个进程分配一个内存空间，每一个进程只允许访问操作系统分配给它的哪一段内存，而不能访问其他进程的。而有时候需要在不同进程之间访问同一段内存，怎么办呢？操作系统给出了 创建访问共享内存的API，需要共享内存的进程可以通过这一组定义好的API来访问多个进程之间共有的内存，各个进程访问这一段内存就像访问一个硬盘上的文件一样。

**内存映射文件与虚拟内存的区别和联系：**<br>
内存映射文件和虚拟内存都是操作系统内存管理的重要部分，两者有相似点也有不同点。联系：虚拟内存和内存映射都是将一部分内容加载到内存，另一部放在磁盘上的一种机制。对于用户而言都是透明的。区别：虚拟内存是硬盘的一部分，是内存和硬盘的数据交换区，许多程序运行过程中把暂时不用的程序数据放入这块虚拟内存，节约内存资源。内存映射是一个文件到一块内存的映射，这样程序通过内存指针就可以对文件进行访问。虚拟内存的硬件基础是分页机制。另外一个基础就是局部性原理（时间局部性和空间局部性），这样就可以将程序的一部分装入内存，其余部分留在外存，当访问信息不存在，再将所需数据调入内存。而内存映射文件并不是局部性，而是使虚拟地址空间的某个区域银蛇磁盘的全部或部分内容，通过该区域对被映射的磁盘文件进行访问，不必进行文件I/O也不需要对文件内容进行缓冲处理。


## 8#套接字(Socket) ##

**套接字机制不但可以单机的不同进程通信，而且使得跨网机器间进程可以通信。<br> 
套接字的创建和使用与管道是有区别的，套接字明确地将客户端与服务器区分开来，可以实现多个客户端连到同一服务器。 <br>
服务器套接字连接过程描述： <br>
首先，服务器应用程序用socket创建一个套接字，它是系统分配服务器进程的类似文件描述符的资源。 接着，服务器调用bind给套接字命名。这个名字是一个标示符，它允许linux将进入的针对特定端口的连接转到正确的服务器进程。 然后，系统调用listen函数开始接听，等待客户端连接。listen创建一个队列并将其用于存放来自客户端的进入连接。 当客户端调用connect请求连接时，服务器调用accept接受客户端连接，accept此时会创建一个新套接字，用于与这个客户端进行通信。 <br>
客户端套接字连接过程描述： <br>
客户端首先调用socket创建一个未命名套接字，让后将服务器的命名套接字作为地址来调用connect与服务器建立连接。 <br>
只要双方连接建立成功，我们就可以像操作底层文件一样来操作socket套接字实现通信。** 
<br>几个基础函数定义：

    #include <sys/types.h>   
    #include <sys/socket.h>   
    int socket(it domain,int type,int protocal);   
    int bind(int socket,const struct sockaddr *address,size_t address_len);   
    int listen(int socket,int backlog);   
    int accept(int socket,struct sockaddr *address,size_t *address_len);   
    int connect(int socket,const struct sockaddr *addrsss,size_t address_len);  

socket编程中，一个服务可以接受多个客户端的连接，可以为每个客户端设定一个消息类型，服务器和客户端直接的通信可以通过此消息类型来发送和接受消息，而且多个客户端之间也可以通过消息类型来区分。


# 各个IPC方式比较 #

## 各种通信方式的比较和优缺点： ##

**管道：速度慢，容量有限，只有父子进程能通讯；创建时分配一个page大小的内存，缓存区大小比较有限。**

**FIFO：任何进程间都能通讯，但速度慢**

**消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；**

**信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；**

**信号量：不能传递复杂消息，只能用来同步；常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段**

**共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决**

**套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信**


<font color = "red">**同时管道、消息队列等方式则是需要将数据通过中间机制进行转换，导致会进行两次数据拷贝，影响效率。而共享内存虽然没有内存拷贝，但是不支持进程间的同步，需要手动控制：**</font>
![](http://o9m6aqy3r.bkt.clouddn.com/IPC%E4%BC%A0%E8%BE%93%E6%80%A7%E8%83%BD.png)
---
>参考：<br>
>[https://blog.csdn.net/a987073381/article/details/52006729](https://blog.csdn.net/a987073381/article/details/52006729 "linux基础——linux进程间通信（IPC）机制总结") 
><br>[https://blog.csdn.net/gatieme/article/details/50908749](https://blog.csdn.net/gatieme/article/details/50908749 "Linux进程间通信的几种方式总结--linux内核剖析")